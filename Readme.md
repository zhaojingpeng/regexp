# 正则表达用法 

-  ^ 以xx开头
-  \s 表示空格
-  *表示匹配零个或者多个
-  g 表示匹配全部
-  (^\s*)表示匹配以空格开头一个或者多个字符
-  str.replace(/(^\s*)/g,'') 表示用''替换所有的空格

##  边界匹配

- ^	    匹配输入字符串的开始位置。
- $	    匹配输入字符串的结束位置。
- \b     匹配一个单词边界，也就是指单词和空格间的位置。
      例如， 'er\b' 可以匹配"never" 中的'er'，但不能匹配 "verb" 中的 'er'。
- \B	和\b相反，匹配非单词边界。
      'er\B' 能匹配 "verb" 中的 'er'，但不能匹配 "never" 中的 'er'。

-  星号(*): 星号代表匹配0或任意次
-  加号(+): 表示匹配前面的字符一次或多次（至少一次).
-  问号(?): 问号也是一个数量词，它代表匹配前一个字符0或1次。

-  中括号[]： 中括号用来表示一个字符集合，
-  如果这个集合有很多元素，如26个字母，数字等，一个个地写在中括号里，未免太麻烦太蠢笨，
-  这时可以用连字符(hyphen)来表示一个范围，
-  如:[a-z]表示小写字母的集合， [0-9]
-  [a-zA-Z]表示大小写字母的集合。
-  脱字符^ (caret).
-  这种写法表示，匹配任何不在该集合中的字符，与上面的用法刚好相反

##  大括号:{}

大括号的作用是指定重复前面一个字符多少遍:

-  {N} 重复N遍
-  {n,m} 重复 n~m 遍
-  {n,}  至少重复n遍
-  {,m} 至多重复m遍


## 预定义类

- .   -- 除了回车和换行符之外的所用字符
-  \w -- (小写w) 表示字母或数字，等价于 [a-zA-Z0-9]
-  \W -- (大写W)非字母且非数字，与\w相反 等价于 '[^A-Za-z0-9_]'
-  \s  --  (小写s)匹配一个空格字符，包括：空格，换行，回车,tab,等价于[ \n\r\t\f]
-  \S --  (大写S)匹配非空格字符，\s的相反 等价于 [^ \f\n\r\t\v]。
-  \d -- 表示10进制数字，等价于 [0-9]
-  \D --	匹配一个非数字字符。等价于 [^0-9]。

详解地址：[regexper.com](https://regexper.com/)
视频：[视频]（http://www.imooc.com/video/12538）

横线的匹配[0-9-],可以在范围类的后面加一个-，表示匹配横线


##  贪婪模式与非贪婪模式

###  贪婪模式是按着最多的方式匹配

- \d{3,6}   例如1245678使用匹配的话会按着6着匹配，'12345678'.replace('/\d{3,6}/g','X')结果为X78

###  非贪婪模式是按着最少的方式匹配

 非贪婪模式需要在后面加个？

- \d{3,6}？   例如1245678使用匹配的话会按着6着匹配，'12345678'.replace('/\d{3,6}/g','X')结果为XX78


## 分组 

- 使用（）

##  或

- 使用 |  例如byron|casper       
  1.'byroncasper'.replace(/(byron|casper)/g,'x')   结果为xx
  2.'byronsperbyrcasper'.replace(/(byr(on|ca)sper)/g,'x')  结果为xx

##  反向分组

- 使用$符号    2015-12-23 变成 12-23-2015  使用 `'2015-12-23'.replace(/(\d{4})-(\d{2})-(\d{2})/g,'$2-$3-$1')`

##  忽略分组 

- 使用?:    
  
  'abc-OK'.replace(/([a-z]{3})-([A-Z]{2})/g,'$2-$1')  
  ####  未使用忽略分组结果为："OK-abc"
  'abc-OK'.replace(/(?:[a-z]{3})-([A-Z]{2})/g,'$2-$1')
  ####  使用忽略分组结果为："$2-OK"

##  前瞻

-  正则表达式从文本头部向尾部开始解析，文本尾部方向，称为"前"。
-  前瞻就是 在正则表达式匹配到规则的时候，向前检查是否符合断言。
-  后顾/后瞻方向相反(javaScript不支持后顾)

####  表示方法

-  正向前瞻exp(?=assert) 
括号内表示断言即限定条件
例如 'a2*3'.replace(/\w(?=\d)/g,"x")  结果x2*3
-  负向前瞻exp(?!assert)

## lastIndex 表示当时结果的下一个结果（在非全局下无效）

```js
var reg2 = /\w/g;

while(reg2.test('ab')){
    console.log(reg2.lastIndex)
}

```

连续3次后
结果：
1.true  
原因：第一次为a
2.true
原因：第二次接着a继续向后匹配结果是b
3.false
原因：第三次接着b继续向后匹配结果没有


```
a1b2c3e4.split(/\d/g)


```