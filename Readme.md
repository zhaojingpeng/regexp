# 正则表达用法 

-  ^ 以xx开头
-  \s 表示空格
-  *表示匹配零个或者多个
-  g 表示匹配全部
-  (^\s*)表示匹配以空格开头一个或者多个字符
-  str.replace(/(^\s*)/g,'') 表示用''替换所有的空格

##  边界匹配

- ^	    匹配输入字符串的开始位置。
- $	    匹配输入字符串的结束位置。
- \b     匹配一个单词边界，也就是指单词和空格间的位置。
      例如， 'er\b' 可以匹配"never" 中的'er'，但不能匹配 "verb" 中的 'er'。
- \B	和\b相反，匹配非单词边界。
      'er\B' 能匹配 "verb" 中的 'er'，但不能匹配 "never" 中的 'er'。

-  星号(*): 星号代表匹配0或任意次
-  加号(+): 表示匹配前面的字符一次或多次（至少一次).
-  问号(?): 问号也是一个数量词，它代表匹配前一个字符0或1次。

-  中括号[]： 中括号用来表示一个字符集合，
-  如果这个集合有很多元素，如26个字母，数字等，一个个地写在中括号里，未免太麻烦太蠢笨，
-  这时可以用连字符(hyphen)来表示一个范围，
-  如:[a-z]表示小写字母的集合， [0-9]
-  [a-zA-Z]表示大小写字母的集合。
-  脱字符^ (caret).
-  这种写法表示，匹配任何不在该集合中的字符，与上面的用法刚好相反

##  大括号:{}

大括号的作用是指定重复前面一个字符多少遍:

-  {N} 重复N遍
-  {n,m} 重复 n~m 遍
-  {n,}  至少重复n遍
-  {,m} 至多重复m遍


## 预定义类

- .   -- 除了回车和换行符之外的所用字符
-  \w -- (小写w) 表示字母或数字，等价于 [a-zA-Z0-9]
-  \W -- (大写W)非字母且非数字，与\w相反 等价于 '[^A-Za-z0-9_]'
-  \s  --  (小写s)匹配一个空格字符，包括：空格，换行，回车,tab,等价于[ \n\r\t\f]
-  \S --  (大写S)匹配非空格字符，\s的相反 等价于 [^ \f\n\r\t\v]。
-  \d -- 表示10进制数字，等价于 [0-9]
-  \D --	匹配一个非数字字符。等价于 [^0-9]。

详解地址：[regexper.com](https://regexper.com/)
视频：[视频]（http://www.imooc.com/video/12538）

横线的匹配[0-9-],可以在范围类的后面加一个-，表示匹配横线


##  贪婪模式与非贪婪模式

###  贪婪模式是按着最多的方式匹配

- \d{3,6}   例如1245678使用匹配的话会按着6着匹配，'12345678'.replace('/\d{3,6}/g','X')结果为X78

###  非贪婪模式是按着最少的方式匹配

 非贪婪模式需要在后面加个？

- \d{3,6}？   例如1245678使用匹配的话会按着6着匹配，'12345678'.replace('/\d{3,6}/g','X')结果为XX78


## 分组 

- 使用（）

##  或

- 使用 |  例如byron|casper       
  1.'byroncasper'.replace(/(byron|casper)/g,'x')   结果为xx
  2.'byronsperbyrcasper'.replace(/(byr(on|ca)sper)/g,'x')  结果为xx

##  反向分组

- 使用$符号    2015-12-23 变成 12-23-2015  使用 `'2015-12-23'.replace(/(\d{4})-(\d{2})-(\d{2})/g,'$2-$3-$1')`

##  忽略分组 

- 使用?:    
  
  'abc-OK'.replace(/([a-z]{3})-([A-Z]{2})/g,'$2-$1')  
  ####  未使用忽略分组结果为："OK-abc"
  'abc-OK'.replace(/(?:[a-z]{3})-([A-Z]{2})/g,'$2-$1')
  ####  使用忽略分组结果为："$2-OK"

##  前瞻

-  正则表达式从文本头部向尾部开始解析，文本尾部方向，称为"前"。
-  前瞻就是 在正则表达式匹配到规则的时候，向前检查是否符合断言。
-  后顾/后瞻方向相反(javaScript不支持后顾)

####  表示方法

-  正向前瞻exp(?=assert) 
括号内表示断言即限定条件
例如 'a2*3'.replace(/\w(?=\d)/g,"x")  结果x2*3
-  负向前瞻exp(?!assert)

## lastIndex 表示当时结果的下一个结果（在非全局下无效）

```js
var reg2 = /\w/g;

while(reg2.test('ab')){
    console.log(reg2.lastIndex)
}

```

连续3次后
结果：
1.true  
原因：第一次为a
2.true
原因：第二次接着a继续向后匹配结果是b
3.false
原因：第三次接着b继续向后匹配结果没有


```
a1b2c3e4.split(/\d/g)
```

#  常用正则表达式大全！（例如：匹配中文、匹配html）

    匹配中文字符的正则表达式： [u4e00-u9fa5]
    评注：匹配中文还真是个头疼的事，有了这个表达式就好办了
    匹配双字节字符(包括汉字在内)：[^x00-xff]
    评注：可以用来计算字符串的长度（一个双字节字符长度计2，ASCII字符计1）
    匹配空白行的正则表达式：ns*r
    评注：可以用来删除空白行
    匹配HTML标记的正则表达式：<(S*?)[^>]*>.*?|<.*? />
    评注：网上流传的版本太糟糕，上面这个也仅仅能匹配部分，对于复杂的嵌套标记依旧无能为力
    匹配首尾空白字符的正则表达式：^s*|s*$
    评注：可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式
    匹配Email地址的正则表达式：w+([-+.]w+)*@w+([-.]w+)*.w+([-.]w+)*
    评注：表单验证时很实用
    匹配网址URL的正则表达式：[a-zA-z]+://[^s]*
    评注：网上流传的版本功能很有限，上面这个基本可以满足需求
    匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$
    评注：表单验证时很实用
    匹配国内电话号码：d{3}-d{8}|d{4}-d{7}
    评注：匹配形式如 0511-4405222 或 021-87888822
    匹配腾讯QQ号：[1-9][0-9]{4,}
    评注：腾讯QQ号从10000开始
    匹配中国邮政编码：[1-9]d{5}(?!d)
    评注：中国邮政编码为6位数字
    匹配身份证：d{15}|d{18}
    评注：中国的身份证为15位或18位
    匹配ip地址：d+.d+.d+.d+
    评注：提取ip地址时有用



    匹配特定数字：
    ^[1-9]d*$　 　 //匹配正整数
    ^-[1-9]d*$ 　 //匹配负整数
    ^-?[1-9]d*$　　 //匹配整数
    ^[1-9]d*|0$　 //匹配非负整数（正整数 + 0）
    ^-[1-9]d*|0$　　 //匹配非正整数（负整数 + 0）
    ^[1-9]d*.d*|0.d*[1-9]d*$　　 //匹配正浮点数
    ^-([1-9]d*.d*|0.d*[1-9]d*)$　 //匹配负浮点数
    ^-?([1-9]d*.d*|0.d*[1-9]d*|0?.0+|0)$　 //匹配浮点数
    ^[1-9]d*.d*|0.d*[1-9]d*|0?.0+|0$　　 //匹配非负浮点数（正浮点数 + 0）
    ^(-([1-9]d*.d*|0.d*[1-9]d*))|0?.0+|0$　　//匹配非正浮点数（负浮点数 + 0）
    评注：处理大量数据时有用，具体应用时注意修正


    匹配特定字符串：
    ^[A-Za-z]+$　　//匹配由26个英文字母组成的字符串
    ^[A-Z]+$　　//匹配由26个英文字母的大写组成的字符串
    ^[a-z]+$　　//匹配由26个英文字母的小写组成的字符串
    ^[A-Za-z0-9]+$　　//匹配由数字和26个英文字母组成的字符串
    ^w+$　　//匹配由数字、26个英文字母或者下划线组成的字符串




    只能输入数字：“^[0-9]*$”
    只能输入n位的数字：“^d{n}$”
    只能输入至少n位数字：“^d{n,}$”
    只能输入m-n位的数字：“^d{m,n}$”
    只能输入零和非零开头的数字：“^(0|[1-9][0-9]*)$”
    只能输入有两位小数的正实数：“^[0-9]+(.[0-9]{2})?$”
    只能输入有1-3位小数的正实数：“^[0-9]+(.[0-9]{1,3})?$”
    只能输入非零的正整数：“^+?[1-9][0-9]*$”
    只能输入非零的负整数：“^-[1-9][0-9]*$”
    只能输入长度为3的字符：“^.{3}$”
    只能输入由26个英文字母组成的字符串：“^[A-Za-z]+$”
    只能输入由26个大写英文字母组成的字符串：“^[A-Z]+$”
    只能输入由26个小写英文字母组成的字符串：“^[a-z]+$”
    只能输入由数字和26个英文字母组成的字符串：“^[A-Za-z0-9]+$”
    只能输入由数字、26个英文字母或者下划线组成的字符串：“^w+$”



    验证用户密码:“^[a-zA-Z]w{5,17}$”正确格式为：以字母开头，长度在6-18之间，
    只能包含字符、数字和下划线。
    验证是否含有^%&'',;=?$"等字符：“[^%&'',;=?$x22]+”
    只能输入汉字：“^[u4e00-u9fa5],{0,}$”
    验证Email地址：“^w+[-+.]w+)*@w+([-.]w+)*.w+([-.]w+)*$”
    验证InternetURL：“^http://([w-]+.)+[w-]+(/[w-./?%&=]*)?$”
    验证电话号码：“^((d{3,4})|d{3,4}-)?d{7,8}$”
    正确格式为：“XXXX-XXXXXXX”，“XXXX-XXXXXXXX”，“XXX-XXXXXXX”，
    “XXX-XXXXXXXX”，“XXXXXXX”，“XXXXXXXX”。
    验证身份证号（15位或18位数字）：“^d{15}|d{}18$”
    验证一年的12个月：“^(0?[1-9]|1[0-2])$”正确格式为：“01”-“09”和“1”“12”
    验证一个月的31天：“^((0?[1-9])|((1|2)[0-9])|30|31)$”
    正确格式为：“01”“09”和“1”“31”。
    匹配中文字符的正则表达式： [u4e00-u9fa5]
    匹配双字节字符(包括汉字在内)：[^x00-xff]
    匹配空行的正则表达式：n[s| ]*r
    匹配HTML标记的正则表达式：/<(.*)>.*|<(.*) />/
    匹配首尾空格的正则表达式：(^s*)|(s*$)
    匹配Email地址的正则表达式：w+([-+.]w+)*@w+([-.]w+)*.w+([-.]w+)*
    匹配网址URL的正则表达式：http://([w-]+.)+[w-]+(/[w- ./?%&=]*)?

